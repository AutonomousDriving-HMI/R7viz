{"version":3,"sources":["../../../src/synchronizers/log-synchronizer.js"],"names":["LogSynchronizer","logs","opts","logName","data","Array","isArray","length","logStartTime","_getTimeFromObject","index","time","Object","keys","startTime","endTime","streams","datum","_lookupStreamDatum","log","startIndex","endIndex","endTimestamp","i","timestamp","object","attributes","transmission_time","BaseSynchronizer"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport BaseSynchronizer from './base-synchronizer';\n\nimport assert from '../utils/assert';\n\nexport default class LogSynchronizer extends BaseSynchronizer {\n  /**\n   * @classdesc\n   * The log streams are arrays of timestamped data objects, and the app\n   * will access the data object from each stream that is in the time range\n   * covering our current timestep.\n   *\n   * @class\n   * @param {Object} logs - Map of logs (arrays) with elements\n   * - Keys will be used as names of logs, and the extracted data will be\n   *   placed in a field with that name.\n   * - Each log is expected to be an array of objects.\n   * - Each log object must contain a GPS timestamp\n   *   either in the `attributes.transmission_time` or the `time` fields\n   */\n  constructor(logs = {}, opts) {\n    super(opts);\n\n    // Set up log state for all logs, so that we can move forward and back\n    this.logs = {};\n\n    for (const logName in logs) {\n      const data = logs[logName];\n      assert(Array.isArray(data) && data.length > 0, 'Invalid log data');\n      const logStartTime = this._getTimeFromObject(data[0]);\n      this.logs[logName] = {\n        data,\n        index: null, // index holds the indices to process\n        time: logStartTime // used to optimize lookup\n      };\n    }\n  }\n\n  _empty() {\n    return !this.logs || Object.keys(this.logs).length === 0;\n  }\n\n  /**\n   * Find and process stream data in the range (start, end] for process\n   * Returns a list of streams sorted by decending time\n   *\n   * Since we have all samples and can find the correct datum for every stream\n   * and only send back an array of 1 element. To do this we will apply the\n   * reverse search here, stopping when we find the entry closest to endTime.\n   *\n   * @param Number startTime - The time to start from.\n   * @param Number endTime - The time to end at.\n   */\n  _getTimeRangeInReverse(startTime, endTime) {\n    const streams = {};\n\n    // Set index based on time range for each stream\n    for (const logName in this.logs) {\n      const datum = this._lookupStreamDatum(logName, startTime, endTime);\n      if (datum) {\n        streams[logName] = datum;\n      }\n    }\n\n    return [streams];\n  }\n\n  /**\n   * @private\n   * Lookups the datum for a stream within the time range.\n   *\n   * This is a mutating function as it tracks last lookup state to\n   * optimize for sequential lookups\n   *\n   * @param {String} logName - which log to sync\n   * @param {Number} startTime - start of time to include data from\n   * @param {Number} endTime - end time to limit data within\n   * @return {Object} - returns datum for this log or null\n   */\n  _lookupStreamDatum(logName, startTime, endTime) {\n    const log = this.logs[logName];\n    assert(log, 'Invalid log');\n\n    // This is an optimization for positive time deltas (playing forward)\n    // If going backwards, just reset and perform full search.\n    if (endTime < log.time) {\n      log.time = 0;\n      log.index = null;\n    }\n\n    const startIndex = log.index || 0;\n    let endIndex = null;\n    let endTimestamp;\n\n    // invalidate\n    log.index = null;\n\n    // Find the range of indices for the given start and end time\n    for (let i = startIndex; i < log.data.length; ++i) {\n      const timestamp = this._getTimeFromObject(log.data[i]);\n      // If timestamp < startTime, sample before our target window, so don't update index\n      if (timestamp > startTime && timestamp <= endTime) {\n        // Within our target window, so update index\n        endIndex = i;\n        endTimestamp = timestamp;\n      } else if (timestamp > endTime) {\n        // Beyond our target window, so exit early\n        break;\n      }\n    }\n\n    // Found no entry\n    if (endIndex === null) {\n      return null;\n    }\n\n    log.index = endIndex;\n    log.time = endTimestamp;\n    return log.data[endIndex];\n  }\n\n  _getTimeFromObject(object) {\n    return object.time || (object.attributes && object.attributes.transmission_time);\n  }\n}\n"],"file":"log-synchronizer.js"}