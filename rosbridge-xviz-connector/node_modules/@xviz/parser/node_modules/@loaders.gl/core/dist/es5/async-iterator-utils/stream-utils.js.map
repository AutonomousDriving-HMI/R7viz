{"version":3,"sources":["../../../src/async-iterator-utils/stream-utils.js"],"names":["getStreamIterator","stream","Symbol","asyncIterator","getIterator","isBrowser","makeBrowserStreamIterator","makeNodeStreamIterator","reader","getReader","read","done","value","releaseLock","data","_readableState","ended","onceReadable","Promise","resolve","once","concatenateReadStream","readStream","arrayBuffer","ArrayBuffer","string","reject","chunk","on","error","complete"],"mappings":"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","sourcesContent":["import {isBrowser} from '../utils/globals';\nimport {concatenateArrayBuffers} from '../binary-utils/memory-copy-utils';\n\nexport function getStreamIterator(stream) {\n  // NODE 10+: stream is an asyncIterator\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n\n  // WhatWG: stream is supposed to have a `getIterator` method\n  if (typeof stream.getIterator === 'function') {\n    return stream.getIterator();\n  }\n\n  return isBrowser ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);\n}\n\n// BROWSER IMPLEMENTATION\n// See https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n\nasync function* makeBrowserStreamIterator(stream) {\n  // In the brower, we first need to get a lock on the stream\n  const reader = stream.getReader();\n\n  try {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Read from the stream\n      const {done, value} = await reader.read();\n      // Exit if we're done\n      if (done) {\n        return;\n      }\n      // Else yield the chunk\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// NODE <10 IMPLEMENTATION\n// See https://github.com/bustle/streaming-iterables, MIT license\n\nasync function* makeNodeStreamIterator(stream) {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield data;\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (stream._readableState.ended) {\n      return;\n    }\n    await onceReadable(stream);\n  }\n}\n\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', resolve);\n  });\n}\n\n// TODO - remove? can this be handled via corresponding AsyncIterator function?\nexport function concatenateReadStream(readStream) {\n  let arrayBuffer = new ArrayBuffer();\n  let string = '';\n\n  return new Promise((resolve, reject) => {\n    readStream.data(chunk => {\n      if (typeof chunk === 'string') {\n        string += chunk;\n      } else {\n        arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);\n      }\n    });\n    readStream.on('error', error => reject(error));\n\n    readStream.on('end', () => {\n      if (readStream.complete) {\n        resolve(arrayBuffer || string);\n      } else {\n        reject('The connection was terminated while the message was still being sent');\n      }\n    });\n  });\n}\n"],"file":"stream-utils.js"}